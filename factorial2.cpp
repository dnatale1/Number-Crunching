
/*                      factorial2.cpp

   Author: David Galilei Natale

   Last edited: November 2023

   Ran program on the Intel Developer Cloud.

   Used Intel C++ compiler 2021.10.0.

   Running on Intel's i9-11900K CPU at 3.5 GHz, this program can            
   approximate 46 billion! in 47 seconds. This is a 5411-fold increase in 
   speed compared to a similar program I ran on a VAX computer back in 1992.

   Compiled with:
   icpc -O3 factorial2.cpp -o proj2main [Enter]
   ./proj2main
                                                                           */

#include <iostream>
#include <cstdlib>
#include <iomanip>
#include <sys/timeb.h>
#include <ctime>
#include <cfloat>

using namespace std;

//This constant is 1e+4900.
const long double UPPER_THRESHOLD = (LDBL_MAX/1.18973149535723177)/1e+32;


void getTime(time_t *, struct timeb *);
void factorial(long long);
void displayTimes(time_t *, time_t *, struct timeb *, struct timeb *);

int main()
{
      long long num = 0;
      struct timeb  startTimeW, endTimeW;
      time_t startTimeC, endTimeC;

      cout<<"\nENTER A WHOLE NUMBER: ";
      cin>>num;

      getTime(&startTimeC, &startTimeW);

      factorial(num);

      getTime(&endTimeC, &endTimeW);

      displayTimes(&startTimeC, &endTimeC, &startTimeW, &endTimeW);

      return 0;
} //end main


void getTime(time_t *cpuTime, struct timeb *wallClockTime)
{
   //get wall-clock time
   ftime(wallClockTime);

   //get cpu time
   time(cpuTime);
}

void factorial(long long n)
{

  long long x = 1;
  long double y = 1;

  //variable to keep track of the # of "e+4900"s in the factorial calculation
  long long eCounter = 0;

  /* Variable to calculate the correct "e+(number)" for answers greater than
     10 to the 4900th power. */
  long long eNumber = 0;

  for(x = 1; x <= n; x++)
  {
    y *= x;
    if(y > UPPER_THRESHOLD)
    {
      y /= UPPER_THRESHOLD;
      eCounter++;
    }
  }

   //if answer is <= 10 to the 4900th power
   if(eCounter == 0)
       cout<<"\n"<<setprecision(4900)<<n<<"! = "<<y<<endl;
   else
   {
       eNumber = eCounter * 4900;
       cout<<"\n"<<setprecision(4900)<<n<<"! = "<<y<<" e+"
           <<eNumber<<endl;
   }

}

void displayTimes(time_t *startCPU, time_t *endCPU, struct timeb *startWall, 
                  struct timeb *endWall)
{
  cout<<"\nWall-clock time = "<<(endWall->time - startWall->time)<<" seconds\n";
  cout<<"CPU time = "<<(*endCPU - *startCPU)<<" seconds\n\n";
}


/*                               SAMPLE RUN:


80000000000000! = 49122426435404797355567107191164335566657687968107588413584222705144385604192162591292171695925292629344692077776324667348321344204896089093735531611626203071584789185473261985353172221224246033215585377670793910111240957654459032436860676794574572872050329437281850787076131378562753048985869044036152448378162893800077875844219827738899537337412620908956647919136562677360569733488679678993729791304929133137855718449708247330991804487709389911190508229252231087664878508479397113454942483398575176110097106199603386464712190123602592280033160182153323618102910218402911754395224151813411781160339605395059919824628423482710112603965654186269564895954659799270909360321296264110528051228243138618049895880337497685490548100194775040925813454454420841483492297155661045078619034090088766080243199861435504835945873599020491330664100928200752071787326505566655881946654038099161647252462909921598403044218976577473872218748125719882479429032371597178611617854454653398910872040991027059346633403216192661821719096667504511208369171337664614921602705643388323845377472307959120824401565939058797070740083562505247055110862286987060404168042065372442616127676110935956884539315645536831670502532248513012448350474642587804430460788053020114811660094200856269748453081299787380967066733450032906620026161919236402173742882533160152938672353944044140010627502028262182072650616405471614978961408316540823194635830307972514594658745313465322279855324309227170867238448725375366591104599003969709623045037412489024524158308563933768200837922581179711759472092183875695936410658437887001187377454352946481530936976184126207564990737810140271685489706826349030300456444735850803349675242223390943766028967561703070585554734016061197339994733653058522388132360230624902131598379477059554816757465438654645787878890642274754105372602308101185887549068147852961324207607938636264734547708804808954257958685663937680411896532493651251335015611581711107313917800563881012715897756850172717967351582851248191082923870828780898551675379104614629043903744905477743737077083853057717733365890274383663431029477952732041890953982698383292261032356268516398444545114796615605901794691478570532585293523870469750044451661735189558849978918693803091120575804602745526818767677579809178337165664917605025324688231059038481791850732083012178699986278848820656071469064330324160013852470820735995607206958044267929661010642738234630325263934584034474752543472036309727259954519601043068231402923167254673975995356896271304459577772530677813491680625126693212384765269736724715250242712319543401198545554309938234979877148858732997707908887956860784834163387456670212760156512590782746424829026512497943435619017229486804766984264251176553873543447873760255972872024615796079626282779257766542530096719282247409833322168829765167312257164477122902014824072831998767503921309784243220972468807194514497437114485046110299153293378326025507185443550537039044909718958757900635495509241253652191334950515528728363952509464206692882832566129923143779748845223540642870025733724760008465690144562521631023512414395249925502608687763887562239160447141758407520236456066479070572327385616738650505733673048019589243807505819484153528209311884823962778557876820390640957794155574945824330749365582303628220722743529729478914491434833361095865340261077450879525983116730942166775540118796473293328827362569423901382620338731440475126032075276526908723554688700595373611816744050070719115806975024446739309376714985044202691905834493892784090624765898141256111121156247711847576879136898828718314447860193200337078602451815876226282700495327771147213099258277224712702905856521552842808127428363736141776789132719174538304048713647451328337700955691104964058066111059660419436510985370240684374378197493679183513187134892630688381534291506503123950190350757730996732378806404204792408657700319241193542619801103310463167167837583562508986014016128153014172451661666298670990996688282361222930875836020276779347140700742621572928764072409347358518912572779911416129556898340772661377678941785773472120695277398569532012830159262290786215403437476021477306318982726799756542647748877697164409855063206056319003498547490265595026401935113583245101435554167928572244816726166814854989976464800103482021939230317800439415426099411391484699894210657376660876505930493425721514057415840581703603757447553915368720853358891843528877039192144609280 e+1077503640402700


Wall-clock time = 82058 seconds
CPU time = 82058 seconds

*/
